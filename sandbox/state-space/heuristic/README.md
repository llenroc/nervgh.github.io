
https://ru.wikipedia.org/wiki/Информированный_метод_поиска
http://36.msiu.ru/books/

---


## Glossary

### fringle (перифериея)
Коллекция узлов, которые были сформированы, но еще не развернуты.


### g(n)
Стоимость достижения данного узла, т.е. стоимость пути от начального узла (корня)
до узла `n`.
```
function g(n) {
    return // code
}
```


### h(n)
Эвристическая функция, т.е. стоимость прохождения от данного узла до цели.
```
function h(n) {
    return // code
}
```
При этом, если `n` - целевой узел, то `h(n) = 0`


### f(n)
Функция оценки.
```
function f(n) {
    return g(n) + h(n);
}
```


---


## Notes


### Поиск оптимального решения

Алгоритм Graph-Search способен отбросить оптимальный путь к повторяющемуся состоянию,
если он не был сформирован в первую очередь. существуют два способа устранения этого
недостатка (или/или):
1. алгоритм Graph-Search должен быть дополнен так, чтобы он отбрасывал наиболее
дорогостоящий из любых двух найденных путей к одному и тому же узлу
2. обеспечение того, чтобы оптимальный путь к любому повторяющемуся состоянию
всегда был первым из тех, по которому следует алгоритм
@see page 158

Свойство 2 (первый найденнй путь - оптимальный) соблюдается, если на функцию
`h(n)` налагается дополнительное требование *преемственности* (монотонности)
@see page 160


### Преемственность (монотонность) эвристической функции
Функция `h(n)` является преемственной, если для любого узла n и для любого
преемника `n'` узла `n`, сформированного в результате любого действия `a`, оценка
стоимости достижения цели из узла `n` не больше, чем стоимость этапа достижения
узла n плюс оценка стоимости достижения цели из узла `n'`:
```
h(n) <= c(n, a, n') + h(n')
```
Это — форма общего неравенства треугольника, которое указывает, что длина любой
стороны треугольника не может превышать сумму длин двух других сторон.
В данном случае треугольник образован узлами `n`, `n'` и целью, ближайшей к `n`.

Еще один важный вывод из определения преемственности является таковым:
если функция `h(n)` преемственна, то значения функции `f(n)` вдоль любого пути
являются неубывающими.
@see page 160

---

## Recursive Best-First Search (RBFS)
Рекурсивный поиск по первому наилучшему совпадению.
Простой рекурсивный алгоритм, в котором предпринимаются попытки имитировать
работу стандартного поиска по первому наилучшему совпадению, но с использованием
только линейного пространства. Он имеет структуру, аналогичную структуре
рекурсивного поиска в глубину, но вместо бесконечного следования вниз по текущему
пути данный алгоритм контролирует f-значение наилучшего альтернативного пути,
доступного из любого предка текущего узла. Если текущий узел превышает данный
предел, то текущий этап рекурсии отменяется и рекурсия продолжается с
альтернативного пути. После отмены данного этапа рекурсии в алгоритме RBFS
происходит замена f-значения каждого узла вдоль данного пути наилучшим
f-значением его дочернего узла. Благодаря этому в алгоритме RBFS запоминается
f-значение наилучшего листового узла из забытого поддерева и поэтому в некоторый
последующий момент времени может быть принято решение о том, стоит ли снова
развертывать это поддерево.
@see page 163


function Recursive-Best-First-Search(problem) returns решение result
    или индикатор неудачи failure
    RBFS(problem, Make-Node(Initial-State[problem]) , ∞)

function RBFS(problem, node, f_limit) returns решение result
    или индикатор неудачи failure и новый предел f-стоимости f_limit
    if Goal-Test[problem](State[node]) then return узел node
        successors <— Expand(node, problem)
    if множество узлов-преемников successors пусто
        then return failure, ∞
    for each s in successors do
        f[s] <— max(g(s) + h(s) , f[node])
    repeat
        best <— узел с наименьшим f-значением в множестве successors
        if f[best] > f_limit then return failure, f[best]
        alternative <— второе после наименьшего f-значение в множестве successors
        result, f[best] <— RBFS(problem, best, min(f_limit, alternative))
    if result !== failure then return result


function Expand(node, problem) returns множество узлов successors
    successors = пустое множество
    for each <action,result> in SuccessorF(node) do
        s = новый узел
        s.State = result
        s.ParentNode=node
        s.Action = action
        s.PathCost = node.PathCost+StepCost(node,action,s)
        s.Depth = node.Depth+1
        добавить узел s к множеству successors
    end
    return successors
end
